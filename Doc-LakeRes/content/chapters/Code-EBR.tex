%==============================================================================
% CHAPITRE DU CODE EBR
%==============================================================================

\chapter{Code - EBR}
\label{chap:code_ebr}

% Mini-table des matières du chapitre
\minitableofcontents

\newpage

%------------------------------------------------------------------------------
% CONTENU
%------------------------------------------------------------------------------

\section{App EBR commun.py}
\label{sec:app_ebr_commun}

\subsection{Chargements des bibliothèques, modules et du dossier racines}
\label{sec:chargements_bibliotheques_modules_dossier_racines}

Cette section permet l'importation de l'ensemble des librairies utilisées par le code, dont celles de Python, celles de librairies externes et les codes d'HydroModPy fonctionnant en POO (programmation orientée objet). Ces différentes librairies sont toutes incluses dans l'environnement \inlinecode{Hydromodpy-0.1} préalablement installé.


En amont de ces librairies, une section \inlinecode{# Filtrer les avertissements} est à renseigner à chaque début de code afin que les alertes de \inlinecode{DeprecationWarnings} ne s'affichent pas, voir \ref{sec:deprecationwarnings}.

\subsection{LogManager}
\label{sec:logmanager-ebr}

La \inlinecode{class LogManager} permet de gérer l'interface verbale entre l'utilisateur et le code, en faisant remonter des logs selon différentes classes avec plus ou moins de précisions et de messages selon le mode choisi. Pour paramétrer le \inlinecode{LogManager}, voir la section \ref{sec:logmanager}.

\section{Initialisation de la classe climatiques}
\label{sec:initialisation_climatiques}

\subsection{Réanalyse Surfex}
\label{sec:reanalyse_surfex}

\subsection{Méthode de création d'un csv pour données climatiques}
\label{sec:csv_donnees_climatiques}

En temps normal, HydroModPy (à l’échelle de la France) fonctionne automatiquement avec les données SIM2. Pour la Bretagne, la recharge et le runoff sont modifiés à partir des données de réanalyse. Ici, des données ISBA brutes issues du serveur FTP de Météo-France sont utilisées directement.

Ce procédé nécessite de fusionner des fichiers NetCDF à chaque itération, ce qui est coûteux en calcul. De plus, les données de réanalyses doivent être extraites dans chaque dossier de sortie, sauf si elles sont externalisées au préalable.

Une méthode plus simple consiste à exécuter une dernière fois la méthode classique, puis à créer un \inlinecode{DataFrame} pour exporter l’ensemble des données climatiques, comme ci-dessous :

\begin{pythoncode}[]
#============================================================================= 
# Exportation des données climatiques 
# ============================================================================= 
# df_climatic = pd.DataFrame({
#     'recharge': BV.climatic.recharge,
#     'runoff': BV.climatic.runoff,
#     'precip': BV.climatic.precip,
#     'evt': BV.climatic.evt,
#     'etp': BV.climatic.etp,
#     't': BV.climatic.t,
# })
# df_climatic.to_csv(os.path.join(data_path, 'Meteo', 'Historiques SIM2', 'climatic_data.csv'))
\end{pythoncode}

Ensuite, toute la classe climatique peut etre mise en commentaire afin de ne garder que la lecture du CSV précédemment créé, comme ci-dessous :

\begin{pythoncode}[]
df_climatic = pd.read_csv(
    os.path.join(data_path, 'Meteo', 'Historiques SIM2', 'climatic_data.csv'),
    index_col=0, parse_dates=True
)
df_climatic.index = pd.to_datetime(df_climatic.index)
df_climatic = df_climatic.loc[
    (df_climatic.index >= pd.Timestamp("01/01/{}".format(first_year))) &
    (df_climatic.index <= pd.Timestamp("31/12/{}".format(last_year)))
]

agg_dict = {
    'recharge': 'sum',
    'runoff': 'sum',
    'precip': 'sum',
    'evt': 'sum',
    'etp': 'sum',
    't': 'mean'
}
df_climatic = df_climatic.resample(freq_input).agg(agg_dict)

BV.climatic.recharge = df_climatic['recharge']
BV.climatic.runoff = df_climatic['runoff']
BV.climatic.precip = df_climatic['precip']
BV.climatic.evt = df_climatic['evt']
BV.climatic.etp = df_climatic['etp']
BV.climatic.t = df_climatic['t']

first_clim = BV.climatic.recharge[0]
BV.climatic.update_first_clim(first_clim)
\end{pythoncode}

\begin{TipBox}
    \textbf{Remarque :} Il est conseillé d’exporter le fichier en données journalières, puis de procéder à la réanalyse (hebdomadaire, mensuelle, etc.) lors de l’import. La sélection automatique des dates minimale et maximale peut être réalisée à l’aide des arguments déjà renseignés.
\end{TipBox}

\section{Paramétrisation}
\label{sec:parametrisation}

\subsection{Simplex}
\label{sec:simplex}

Le Simplex de Nelder-Mead est un algorithme d'optimisation non-linéaire particulièrement adapté à la calibration de modèles hydrogéologiques \parencite{gao_implementing_2012}. Son principe repose sur la construction d'une figure géométrique à \(N+1\) sommets dans un espace à \(N\) dimensions, où \(N\) représente le nombre de paramètres à calibrer.

\vspace{2em}
\noindent\textbf{**Formulation de Nelder-Mead**}\\

L'algorithme fonctionne en minimisant le volume du simplexe à travers une série d'opérations géométriques jusqu'à convergence vers le jeu de paramètres optimal. À chaque itération, les valeurs de la fonction objectif aux sommets sont ordonnées:
\begin{equation}
f(x_1) \leq f(x_2) \leq \ldots \leq f(x_{N+1})
\end{equation}

Quatre opérations géométriques principales sont appliquées \parencite{gao_implementing_2012}:
\begin{itemize}
\item \textit{Réflexion}: création d'un point $x_r$ en reflétant le plus mauvais sommet $x_{N+1}$ par rapport au centroïde des autres sommets
\item \textit{Expansion}: si le point réfléchi est prometteur, on étend dans cette direction (point $x_e$)
\item \textit{Contraction}: si le point réfléchi n'améliore pas suffisamment la solution, on contracte le simplexe vers l'intérieur (point $x_c$)
\item \textit{Rétrécissement}: si aucune des opérations précédentes n'améliore la solution, on rétrécit l'ensemble du simplexe vers le meilleur sommet $x_1$
\end{itemize}

La version adaptative proposée par \textcite{gao_implementing_2012} améliore l'algorithme classique en ajustant dynamiquement les paramètres de réflexion ($\rho$), d'expansion ($\chi$), de contraction ($\gamma$) et de rétrécissement ($\sigma$) en fonction de la dimension du problème:
\begin{align}
\rho &= 1, \quad \chi = 1 + \frac{2}{N}, \quad \gamma = 0.75 - \frac{0.5}{N}, \quad \sigma = 1 - \frac{1}{N}
\end{align}

\vspace{2em}
\noindent\textbf{**Intégration dans le flux d'exécution**}\\

L'algorithme Simplex est intégré juste avant le lancement des simulations MODFLOW, entre la mise à jour des paramètres du modèle et l'exécution standard de la simulation. Une condition booléenne permet de contrôler l'activation de la calibration automatique:

\inlinecode{if run_simplex then : # executer la calibration}

Une fois la paramétrisation terminée, le meilleur jeu de paramètres est utilisé pour mettre à jour les valeurs initiales et lancer la simulation standard.

\vspace{2em}
\noindent\textbf{**Paramètres calibrés**}\\

Dans notre implémentation actuelle, trois paramètres clés sont calibrés:
\begin{itemize}
\item Épaisseur de l'aquifère ($e$)
\item Porosité ($\phi$)
\item Conductivité hydraulique ($K$)
\end{itemize}

Le Simplex est particulièrement adapté pour calibrer entre 2 et 5 paramètres maximum, ce qui correspond bien à notre cas d'utilisation. Cette efficacité pour un nombre limité de paramètres est l'une des raisons pour lesquelles la méthode est privilégiée dans notre contexte hydrogéologique \parencite{gao_implementing_2012}.

\vspace{2em}
\noindent\textbf{**Fonction objectif et sélection des données**}\\

La fonction objectif utilisée pour l'évaluation de performance est le critère de Nash-Sutcliffe (NSE):
\begin{equation}\label{eq:nse}
\text{NSE} = 1 - \frac{\sum_{t=1}^{T}(Q_{obs,t} - Q_{sim,t})^2}{\sum_{t=1}^{T}(Q_{obs,t} - \bar{Q}_{obs})^2}
\end{equation}

où $Q_{obs,t}$ représente le débit observé au temps $t$, $Q_{sim,t}$ le débit simulé, et $\bar{Q}_{obs}$ la moyenne des débits observés.

Une fonction dédiée en début de script permet de sélectionner les chroniques de données qui seront utilisées pour la calibration. L'utilisateur peut définir une période spécifique en précisant les années minimale et maximale dans la plage commune des données de simulation et d'observation. Cette approche permet d'optimiser le modèle sur une période représentative tout en excluant potentiellement des périodes atypiques qui pourraient biaiser la calibration.

\vspace{2em}
\noindent\textbf{**Critères de convergence**}\\

Suivant les recommandations de \textcite{gao_implementing_2012}, la convergence de l'algorithme est évaluée par deux critères:
\begin{itemize}
\item L'écart-type des valeurs de la fonction objectif aux sommets du simplexe est inférieur à un seuil prédéfini
\item Le diamètre maximal du simplexe (distance maximale entre deux sommets) est inférieur à une tolérance définie
\end{itemize}

Lorsque ces deux critères sont satisfaits simultanément, l'algorithme s'arrête et retourne le meilleur jeu de paramètres identifié \parencite{gao_implementing_2012}.
