%==============================================================================
% CHAPITRE DU CODE EBR
%==============================================================================

\chapter{Code - EBR}
\label{chap:code_ebr}

% Mini-table des matières du chapitre
\minitableofcontents

\newpage

%------------------------------------------------------------------------------
% CONTENU
%------------------------------------------------------------------------------

\section{App EBR commun.py}
\label{sec:app_ebr_commun}

\subsection{Chargements des bibliothèques, modules et du dossier racines}
\label{sec:chargements_bibliotheques_modules_dossier_racines}

Cette section permet l'importation de l'ensemble des librairies utilisées par le code, dont celles de Python, celles de librairies externes et les codes d'HydroModPy fonctionnant en POO (programmation orientée objet). Ces différentes librairies sont toutes incluses dans l'environnement \inlinecode{Hydromodpy-0.1} préalablement installé.


En amont de ces librairies, une section \inlinecode{# Filtrer les avertissements} est à renseigner à chaque début de code afin que les alertes de \inlinecode{DeprecationWarnings} ne s'affichent pas, voir \ref{sec:deprecationwarnings}.

\subsection{LogManager}
\label{sec:logmanager-ebr}

La \inlinecode{class LogManager} permet de gérer l'interface verbale entre l'utilisateur et le code, en faisant remonter des logs selon différentes classes avec plus ou moins de précisions et de messages selon le mode choisi. Pour paramétrer le \inlinecode{LogManager}, voir la section \ref{sec:logmanager}.

\section{Initialisation de la classe climatiques}
\label{sec:initialisation_climatiques}

\subsection{Réanalyse Surfex}
\label{sec:reanalyse_surfex}

\subsection{Méthode de création d'un csv pour données climatiques}
\label{sec:csv_donnees_climatiques}

En temps normal, HydroModPy (à l’échelle de la France) fonctionne automatiquement avec les données SIM2. Pour la Bretagne, la recharge et le runoff sont modifiés à partir des données de réanalyse. Ici, des données ISBA brutes issues du serveur FTP de Météo-France sont utilisées directement.

Ce procédé nécessite de fusionner des fichiers NetCDF à chaque itération, ce qui est coûteux en calcul. De plus, les données de réanalyses doivent être extraites dans chaque dossier de sortie, sauf si elles sont externalisées au préalable.

Une méthode plus simple consiste à exécuter une dernière fois la méthode classique, puis à créer un \inlinecode{DataFrame} pour exporter l’ensemble des données climatiques, comme ci-dessous :

\begin{minted}{python}
#============================================================================= 
# Exportation des données climatiques 
# ============================================================================= 
# df_climatic = pd.DataFrame({
#     'recharge': BV.climatic.recharge,
#     'runoff': BV.climatic.runoff,
#     'precip': BV.climatic.precip,
#     'evt': BV.climatic.evt,
#     'etp': BV.climatic.etp,
#     't': BV.climatic.t,
# })
# df_climatic.to_csv(os.path.join(data_path, 'Meteo', 'Historiques SIM2', 'climatic_data.csv'))
\end{minted}

Ensuite, toute la classe climatique peut etre mise en commentaire afin de ne garder que la lecture du CSV précédemment créé, comme ci-dessous :

\begin{minted}{python}
df_climatic = pd.read_csv(
    os.path.join(data_path, 'Meteo', 'Historiques SIM2', 'climatic_data.csv'),
    index_col=0, parse_dates=True
)
df_climatic.index = pd.to_datetime(df_climatic.index)
df_climatic = df_climatic.loc[
    (df_climatic.index >= pd.Timestamp("01/01/{}".format(first_year))) &
    (df_climatic.index <= pd.Timestamp("31/12/{}".format(last_year)))
]

agg_dict = {
    'recharge': 'sum',
    'runoff': 'sum',
    'precip': 'sum',
    'evt': 'sum',
    'etp': 'sum',
    't': 'mean'
}
df_climatic = df_climatic.resample(freq_input).agg(agg_dict)

BV.climatic.recharge = df_climatic['recharge']
BV.climatic.runoff = df_climatic['runoff']
BV.climatic.precip = df_climatic['precip']
BV.climatic.evt = df_climatic['evt']
BV.climatic.etp = df_climatic['etp']
BV.climatic.t = df_climatic['t']

first_clim = BV.climatic.recharge[0]
BV.climatic.update_first_clim(first_clim)
\end{minted}

\begin{TipBox}
    \textbf{Remarque :} Il est conseillé d’exporter le fichier en données journalières, puis de procéder à la réanalyse (hebdomadaire, mensuelle, etc.) lors de l’import. La sélection automatique des dates minimale et maximale peut être réalisée à l’aide des arguments déjà renseignés.
\end{TipBox}

\section{Paramétrisation}
\label{sec:parametrisation}

\subsection{Simplex de Nelder-Mead}
\label{sec:simplex}

Le Simplex de Nelder-Mead est un algorithme d'optimisation non-linéaire adapté aux problèmes où le calcul des dérivées est complexe. Son principe repose sur la manipulation d'une figure géométrique à \(N+1\) sommets dans un espace à \(N\) dimensions.

\subsubsection{Principe et enchaînement des opérations}

L'algorithme utilise quatre opérations géométriques principales qui s'enchaînent selon un arbre de décision précis. À chaque itération, les valeurs de la fonction objectif aux sommets sont d'abord ordonnées:
\begin{equation}\label{eq:ordre_simplex}
f(x_1) \leq f(x_2) \leq \ldots \leq f(x_{N+1})
\end{equation}

Où $x_1$ est le meilleur sommet et $x_{N+1}$ le pire. Le centroïde des $N$ meilleurs sommets est calculé comme $x_0 = \frac{1}{N}\sum_{i=1}^{N}x_i$.

L'enchaînement des opérations suit alors la logique suivante:

\noindent\textbf{Enchaînement des opérations dans une itération du Simplex de Nelder-Mead:}

\begin{enumerate}
\item \textbf{Réflexion} (toujours effectuée en premier):
   \begin{itemize}
   \item Calculer $x_r = x_0 + \alpha(x_0 - x_{N+1})$ et évaluer $f_r = f(x_r)$
   \end{itemize}

\item \textbf{Décision} (une seule branche est suivie):
   \begin{itemize}
   \item Si $f(x_1) \leq f_r < f(x_N)$ : \\
         Remplacer $x_{N+1}$ par $x_r$ (simple acceptation de la réflexion)
   
   \item Si $f_r < f(x_1)$ : \\
         \textbf{Expansion}: Calculer $x_e = x_0 + \beta(x_r - x_0)$ et évaluer $f_e = f(x_e)$ \\
         Si $f_e < f_r$ : Remplacer $x_{N+1}$ par $x_e$ \\
         Sinon : Remplacer $x_{N+1}$ par $x_r$
   
   \item Si $f_r \geq f(x_N)$ et $f_r < f(x_{N+1})$ : \\
         \textbf{Contraction externe}: Calculer $x_c = x_0 + \gamma(x_r - x_0)$ et évaluer $f_c = f(x_c)$ \\
         Si $f_c \leq f_r$ : Remplacer $x_{N+1}$ par $x_c$ \\
         Sinon : Appliquer \textbf{Rétrécissement}
   
   \item Si $f_r \geq f(x_{N+1})$ : \\
         \textbf{Contraction interne}: Calculer $x_c = x_0 + \gamma(x_{N+1} - x_0)$ et évaluer $f_c = f(x_c)$ \\
         Si $f_c < f(x_{N+1})$ : Remplacer $x_{N+1}$ par $x_c$ \\
         Sinon : Appliquer \textbf{Rétrécissement}
   \end{itemize}

\item \textbf{Rétrécissement} (seulement si la contraction a échoué):
   \begin{itemize}
   \item Pour $i = 2, \ldots, N+1$, remplacer $x_i$ par $x_1 + \delta(x_i - x_1)$
   \end{itemize}
\end{enumerate}

Où les coefficients standards sont $\alpha = 1$ (réflexion), $\beta = 2$ (expansion), $\gamma = 0.5$ (contraction) et $\delta = 0.5$ (rétrécissement). Dans notre implémentation adaptative, ils dépendent de la dimension $N$ du problème:
\begin{align}
\alpha &= 1, \quad \beta = 1 + \frac{2}{N}, \quad \gamma = 0.75 - \frac{0.5}{N}, \quad \delta = 1 - \frac{1}{N}
\end{align}

Points importants à noter:
\begin{itemize}
    \item Une seule des branches de l'arbre de décision est suivie à chaque itération
    \item Le rétrécissement n'est appliqué qu'en dernier recours, si les contractions échouent
    \item Pour les problèmes de grande dimension, les opérations de réflexion deviennent dominantes, réduisant l'efficacité de l'algorithme
\end{itemize}

\subsubsection{Normalisation et mise à l'échelle des paramètres}

Pour garantir une convergence efficace, nous normalisons tous les paramètres dans l'intervalle [0,1] avant optimisation:
\begin{equation}
x_{norm} = \frac{x - x_{min}}{x_{max} - x_{min}}
\end{equation}

Cette normalisation est particulièrement importante pour la conductivité hydraulique ($K$) qui varie sur plusieurs ordres de grandeur. Pour ce paramètre, nous utilisons une échelle logarithmique:
\begin{equation}
K_{norm} = \frac{\log_{10}(K) - \log_{10}(K_{min})}{\log_{10}(K_{max}) - \log_{10}(K_{min})}
\end{equation}

\subsubsection{Implémentation dans le code}

L'algorithme est intégré via la bibliothèque SciPy:

\begin{minted}{python}
from scipy.optimize import minimize

# Normalisation des paramètres
def normalize(x, xmin, xmax):
    """Normalise une valeur x selon les bornes xmin et xmax"""
    return (x - xmin) / (xmax - xmin)

def denormalize(x_norm, xmin, xmax):
    """Dénormalise une valeur x_norm selon les bornes xmin et xmax"""
    return x_norm * (xmax - xmin) + xmin

# Fonction objectif normalisée
def erreur_modele_norm(params_norm):
    # Dénormalisation des paramètres
    log_hk_value = denormalize(params_norm[0], log_hk_min, log_hk_max)
    hk_value = 10**log_hk_value
    sy_value = denormalize(params_norm[1], sy_min, sy_max)
    thick_value = denormalize(params_norm[2], thick_min, thick_max)
    
    # Mise à jour du modèle avec les nouveaux paramètres
    BV.hydraulic.update_hk(hk_value)
    BV.hydraulic.update_sy(sy_value)
    BV.hydraulic.update_thick(thick_value)
    
    # Simulation du modèle avec ces paramètres
    model_modflow = BV.preprocessing_modflow()
    success_modflow = BV.processing_modflow(model_modflow)
    BV.postprocessing_timeseries(model_modflow)
    
    # Calcul du critère de Nash-Sutcliffe
    nse = 1 - (numerator / denominator) 
    return 1 - nse  # On minimise 1-NSE

# Exécution de l'optimisation
result = minimize(
    erreur_modele_norm, 
    x0_norm,  # Paramètres initiaux normalisés
    method='Nelder-Mead',
    options={
        'xatol': 0.01,  # Tolérance sur les paramètres
        'fatol': 0.01,  # Tolérance sur la fonction
        'maxiter': 200,  # Nombre max d'itérations
        'disp': True     # Affichage des informations
    }
)
\end{minted}

\subsubsection{Paramètres calibrés}

Dans notre implémentation, trois paramètres hydrogéologiques fondamentaux sont calibrés:

\begin{table}[h]
\centering
\caption{Paramètres hydrogéologiques calibrés et leurs bornes}
\label{tab:parametres_calibres}
\begin{tabular}{|l|c|c|c|l|}
\hline
\textbf{Paramètre} & \textbf{Minimum} & \textbf{Maximum} & \textbf{Unité} & \textbf{Influence} \\
\hline
Conductivité ($K$) & $10^{-6}$ & $10^{-3}$ & m/s & Capacité de l'aquifère à transmettre l'eau \\
\hline
Porosité efficace ($S_y$) & 0.001 & 0.1 & - & Capacité de stockage \\
\hline
Épaisseur ($e$) & 20 & 40 & m & Volume de l'aquifère disponible \\
\hline
\end{tabular}
\end{table}

Le Simplex est particulièrement adapté pour ce nombre limité de paramètres. Sa convergence reste efficace et rapide pour des problèmes de dimension inférieure à 5.

\subsubsection{Fonction objectif et sélection des données}

La fonction objectif utilisée est le critère de Nash-Sutcliffe (NSE):
\begin{equation}\label{eq:nse}
\text{NSE} = 1 - \frac{\sum_{t=1}^{T}(Q_{obs,t} - Q_{sim,t})^2}{\sum_{t=1}^{T}(Q_{obs,t} - \bar{Q}_{obs})^2}
\end{equation}

Notre implémentation permet de sélectionner précisément les données utilisées pour la calibration:

\begin{minted}{python}
def filter_dates(dates):
    """Filtre les dates selon des critères temporels et saisonniers"""
    mask = pd.Series(True, index=dates)
    
    if use_time_filter:
        mask = mask & (dates >= calib_start_date) & (dates <= calib_end_date)
    
        if use_seasonal_filter:
            def is_in_season(date):
                start = pd.Timestamp(date.year, season_start_month, season_start_day)
                if season_end_month < season_start_month:
                    end = pd.Timestamp(date.year + 1, season_end_month, season_end_day)
                else:
                    end = pd.Timestamp(date.year, season_end_month, season_end_day)
                return (date >= start) & (date <= end)
            
            seasonal_mask = dates.map(is_in_season)
            mask = mask & seasonal_mask

    return mask
\end{minted}

Cette approche permet de concentrer la calibration sur des périodes représentatives, en excluant si nécessaire des événements extrêmes ou des saisons particulières.

\subsubsection{Avantages et limitations}

\begin{table}[h]
\centering
\caption{Avantages et limitations du Simplex dans notre contexte}
\label{tab:avantages_limitations}
\begin{tabular}{|p{7cm}|p{7cm}|}
\hline
\textbf{Avantages} & \textbf{Limitations} \\
\hline
Ne nécessite pas le calcul des dérivées & Peut converger vers des minima locaux \\
\hline
Robuste face aux irrégularités de la fonction objectif & Nombre d'itérations potentiellement élevé \\
\hline
Implémentation simple via SciPy & Sensible à l'initialisation du simplexe \\
\hline
Adapté aux problèmes avec peu de paramètres & Performances réduites au-delà de 5 paramètres \\
\hline
\end{tabular}
\end{table}

Dans notre contexte hydrogéologique, le Simplex offre un excellent compromis entre simplicité d'implémentation et efficacité de calibration pour les principaux paramètres qui contrôlent le comportement hydraulique du modèle.